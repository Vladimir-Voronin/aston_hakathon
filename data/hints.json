{
  "trees_1_flattening_json": [
    "Ох уж эти JSON объекты, они вложены друг в друга, один ключ указывает на словарь, другой ключ\n\tна список, ещё один на строку... Придется использовать рекурсию, чтобы обойти их в глубину.\n\tНачните с простого - в каком объекте мы будем сохранять новые ключи и значения? Как сделать так,\n\tчтобы при проходе рекурсии мы могли обновлять этот объект?",
    "Каждый атрибут в JSON ссылается на объект типа dict, list или str. По разному ли обрабатываются эти объекты?",
    "Слыхали что-нибудь про dict.items() и функцию enumerate()? Это очень удобные способы\n\tпроходиться по словарям и спискам. Они наверняка вам понадобятся 0_0"
  ],
  "trees_2_analytical_chaos": [
    "Библиотека pathlib - это самая удобная вещь на свете. В ней есть класс Path, который позволяет работать\n\tс путями с помощью ООП интерфейса. Используйте его для проверки является ли путь файлом - is_file(),\n\tполучения расширения файла - suffix() и самое главное - обхода дерева файлов с помощью .rglob(*).",
    "В библиотеке csv есть функция csv.reader(file) - с помощью неё вы можете читать данные из csv файла.\n\tИмея в руках библиотеки pathlib и csv, как можно проверить соответствие файлов csv указанным правилам?"
  ]
}