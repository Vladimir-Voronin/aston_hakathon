{
  "trees_1_flattening_json": {
    "description": "",
    "additional_info": "",
    "hints": [
      "Ох уж эти JSON объекты, они вложены друг в друга, один ключ указывает на словарь, другой ключ\n\tна список, ещё один на строку... Придется использовать рекурсию, чтобы обойти их в глубину.\n\tНачните с простого - в каком объекте мы будем сохранять новые ключи и значения? Как сделать так,\n\tчтобы при проходе рекурсии мы могли обновлять этот объект?",
      "Каждый атрибут в JSON ссылается на объект типа dict, list или str. По разному ли обрабатываются эти объекты?",
      "Слыхали что-нибудь про dict.items() и функцию enumerate()? Это очень удобные способы\n\tпроходиться по словарям и спискам. Они наверняка вам понадобятся 0_0"
    ]
  },
  "trees_2_analytical_chaos": {
    "description": "",
    "additional_info": "",
    "hints": [
      "Библиотека pathlib - это самая удобная вещь на свете. В ней есть класс Path, который позволяет работать\n\tс путями с помощью ООП интерфейса. Используйте его для проверки является ли путь файлом - is_file(),\n\tполучения расширения файла - suffix() и самое главное - обхода дерева файлов с помощью .rglob(*).",
      "В библиотеке csv есть функция csv.reader(file) - с помощью неё вы можете читать данные из csv файла.\n\tИмея в руках библиотеки pathlib и csv, как можно проверить соответствие файлов csv указанным правилам?"
    ]
  },
  "trees_3_managers_tree": {
    "description": "",
    "additional_info": "",
    "hints": [
      "dataclass автоматически создает метод __init__. Таким образом, для создания экзмепляров\n\tEmployee мы можем передавать иеннованные аргументы, к примеру - Employee(id=1, name='Vova'...).\n\tТолько вот незадача, некоторые JSON объекты не имеют всех аттрибутов, поэтому придется\n\tнайти способ объявлять экземпляры даже в случаях, когда к примеру не указаны salary или name. Как будем это делать?",
      "Корнем дерева будет являться экземпляр Employee, у которого manager_id == None. Он такой один.\n\tНужно найти способ получить этот объект и далее, придумать алгоритм создания дерева, начиная с корня (этого объекта)",
      "Необязательно все делать внутри одной функции. Бывает удобно вынести рекурсивную часть в отдельную функцию."
    ]
  }
}